Index: linux-stage/fs/ext4/ext4.h
===================================================================
--- linux-stage.orig/fs/ext4/ext4.h
+++ linux-stage/fs/ext4/ext4.h
@@ -1672,6 +1672,13 @@ struct ext4_sb_info {
 	atomic_t s_mb_discarded;
 	atomic_t s_lock_busy;
 
+	/* per cN loop min allocation failure size */
+	long s_mb_cX_failed_size[3];
+	/* and their TTL */
+	long s_mb_cX_failed_ttl[3];
+	/* initial TTL value, 0 to disable the feature */
+	long s_mb_cX_ttl0;
+
 	/* locality groups */
 	struct ext4_locality_group __percpu *s_locality_groups;
 
Index: linux-stage/fs/ext4/mballoc.c
===================================================================
--- linux-stage.orig/fs/ext4/mballoc.c
+++ linux-stage/fs/ext4/mballoc.c
@@ -2713,6 +2713,16 @@ ext4_mb_regular_allocator(struct ext4_al
 repeat:
 	for (; cr < 4 && ac->ac_status == AC_STATUS_CONTINUE; cr++) {
 		ac->ac_criteria = cr;
+
+		if (cr < 3 &&
+		    sbi->s_mb_cX_failed_size[cr] != 0 &&
+		    ac->ac_g_ex.fe_len >= sbi->s_mb_cX_failed_size[cr]) {
+			if (--(sbi->s_mb_cX_failed_ttl[cr]) > 0)
+				continue;
+			sbi->s_mb_cX_failed_ttl[cr] = 0;
+			sbi->s_mb_cX_failed_size[cr] = 0;
+		}
+
 		/*
 		 * searching for the right group start
 		 * from the goal value specified
@@ -2727,8 +2737,8 @@ repeat:
 
 			cond_resched();
 			if (new_cr != cr) {
-				cr = new_cr;
-				goto repeat;
+				i = ngroups;
+				break;
 			}
 
 			/*
@@ -2794,9 +2804,18 @@ repeat:
 			if (ac->ac_status != AC_STATUS_CONTINUE)
 				break;
 		}
-		/* Processed all groups and haven't found blocks */
-		if (sbi->s_mb_stats && i == ngroups)
-			atomic64_inc(&sbi->s_bal_cX_failed[cr]);
+		if (i == ngroups) {
+			if (sbi->s_mb_stats)
+				atomic64_inc(&sbi->s_bal_cX_failed[cr]);
+			if (cr < 3 &&
+			    (sbi->s_mb_cX_failed_size[cr] == 0 ||
+			    sbi->s_mb_cX_failed_size[cr] > ac->ac_g_ex.fe_len)) {
+				sbi->s_mb_cX_failed_size[cr] = ac->ac_g_ex.fe_len;
+				sbi->s_mb_cX_failed_ttl[cr] = sbi->s_mb_cX_ttl0;
+			}
+			if (cr != new_cr)
+				cr = new_cr - 1;
+		}
 	}
 
 	if (ac->ac_b_ex.fe_len > 0 && ac->ac_status != AC_STATUS_FOUND &&
@@ -3637,6 +3656,9 @@ int ext4_mb_init(struct super_block *sb)
 		sbi->s_mb_klta_rate = 0;
 	else
 		sbi->s_mb_klta_rate = MB_KLTA_RATE_DEFAULT;
+
+	sbi->s_mb_cX_ttl0 = EXT4_MB_FAIL_SIZE_TTL;
+
 	/*
 	 * The default group preallocation is 512, which for 4k block
 	 * sizes translates to 2 megabytes.  However for bigalloc file
Index: linux-stage/fs/ext4/mballoc.h
===================================================================
--- linux-stage.orig/fs/ext4/mballoc.h
+++ linux-stage/fs/ext4/mballoc.h
@@ -68,6 +68,9 @@
  */
 #define MB_DEFAULT_ORDER2_REQS		8
 
+/* TTL for failed allocation request size */
+#define EXT4_MB_FAIL_SIZE_TTL           100
+
 /*
  * default group prealloc size 512 blocks
  */
Index: linux-stage/fs/ext4/sysfs.c
===================================================================
--- linux-stage.orig/fs/ext4/sysfs.c
+++ linux-stage/fs/ext4/sysfs.c
@@ -23,6 +23,7 @@ typedef enum {
 	attr_delayed_allocation_blocks,
 	attr_mb_klta_rate,
 	attr_mb_klta_start,
+	attr_mb_cX_ttl0,
 	attr_session_write_kbytes,
 	attr_lifetime_write_kbytes,
 	attr_reserved_clusters,
@@ -163,6 +164,24 @@ static ssize_t mb_klta_start_store(struc
 	return count;
 }
 
+static ssize_t mb_cX_ttl0_store(struct ext4_sb_info *sbi,
+				const char *buf, size_t count)
+{
+	unsigned long val;
+	int ret;
+	int cr;
+
+	ret = kstrtol(buf, 0, &val);
+	if (ret || val < 0)
+		return -EINVAL;
+
+	sbi->s_mb_cX_ttl0 = val;
+	for (cr = 0; cr < 3; cr++)
+		sbi->s_mb_cX_failed_size[cr] = 0;
+
+	return count;
+}
+
 #define EXT4_ATTR(_name,_mode,_id)					\
 static struct ext4_attr ext4_attr_##_name = {				\
 	.attr = {.name = __stringify(_name), .mode = _mode },		\
@@ -281,6 +300,7 @@ EXT4_RW_ATTR_SBI_UI(mb_prefetch, s_mb_pr
 EXT4_RW_ATTR_SBI_UI(mb_prefetch_limit, s_mb_prefetch_limit);
 EXT4_RW_ATTR_SBI_UI(mb_reset_last_group, s_mb_reset_last_group);
 EXT4_RW_ATTR_SBI_UL(last_trim_minblks, s_last_trim_minblks);
+EXT4_ATTR_FUNC(mb_cX_ttl0, 0644);
 
 static unsigned int old_bump_val = 128;
 EXT4_ATTR_PTR(max_writeback_mb_bump, 0444, pointer_ui, &old_bump_val);
@@ -339,6 +359,7 @@ static struct attribute *ext4_attrs[] =
 	ATTR_LIST(mb_prefetch_limit),
 	ATTR_LIST(mb_reset_last_group),
 	ATTR_LIST(last_trim_minblks),
+	ATTR_LIST(mb_cX_ttl0),
 	NULL,
 };
 ATTRIBUTE_GROUPS(ext4);
@@ -425,6 +446,8 @@ static ssize_t ext4_attr_show(struct kob
 		return sysfs_emit(buf, "%u\n", sbi->s_mb_klta_rate);
 	case attr_mb_klta_start:
 		return sysfs_emit(buf, "%u\n", sbi->s_mb_klta_start);
+	case attr_mb_cX_ttl0:
+		return sysfs_emit(buf, "%ld\n", sbi->s_mb_cX_ttl0);
 	case attr_session_write_kbytes:
 		return session_write_kbytes_show(sbi, buf);
 	case attr_lifetime_write_kbytes:
@@ -530,6 +553,8 @@ static ssize_t ext4_attr_store(struct ko
 		return mb_klta_rate_store(sbi, buf, len);
 	case attr_mb_klta_start:
 		return mb_klta_start_store(sbi, buf, len);
+	case attr_mb_cX_ttl0:
+		return mb_cX_ttl0_store(sbi, buf, len);
 	case attr_inode_readahead:
 		return inode_readahead_blks_store(sbi, buf, len);
 	case attr_trigger_test_error:
